export const questions = [
  {
    question: "Що виведе код console.log(typeof null)?",
    options: ["null", "object", "undefined", "function"],
    answer: "object",
    explanation: "Це особливість JavaScript — null повертає тип object.",
    id: "1",
    credit: 1,
  },
  {
    question: "Який результат поверне вираз 5 == '5'?",
    options: ["true", "false", "null", "undefined"],
    answer: "true",
    explanation:
      "== порівнює тільки значення, ігноруючи типи, тому результат буде true.",
    id: "2",
    credit: 1,
  },
  {
    question: "Що виконає цикл for?",
    options: [
      "Виконає блок коду, доки умова істинна",
      "Виконає блок коду один раз",
      "Виконає блок коду по умовам кроку",
      "Не виконає нічого",
    ],
    answer: "Виконає блок коду, доки умова істинна",
    explanation:
      "Цикл for виконує блок коду, поки умова залишається істинною, поступово змінюючи значення за допомогою кроку.",
    id: "3",
    credit: 2,
  },
  {
    question: "Що поверне наступний код: const a = 0 || 5?",
    options: [true, 0, false, 5],
    answer: "5",
    explanation:
      "Оператор || повертає перше значення, що є істинним, тому результат буде 5.",
    id: "4",
    credit: 1,
  },
  {
    question: "Що повертає метод map() для масиву?",
    options: [
      "Масив тих самих елементів",
      "Новий масив із зміненими елементами",
      "Оригінальний масив",
      "Масив у зворотному порядку",
    ],
    answer: "Новий масив із зміненими елементами",
    explanation:
      "Метод map() повертає новий масив, змінюючи кожен елемент за допомогою переданої функції.",
    id: "5",
    credit: 1,
  },
  {
    question: "Що поверне наступний код: typeof NaN?",
    options: ["NaN", "object", "number", "string"],
    answer: "number",
    explanation: "В JavaScript NaN вважається числовим типом.",
    id: "6",
    credit: 2,
  },
  {
    question:
      "Що відбувається з this в стрілковій функції, якщо вона викликається в об'єкті?",
    options: [
      "Залишається тим самим, що був при створенні функції",
      "Прив'язується до об'єкта",
      "Прив'язується до window",
      "Втрачає значення",
    ],
    answer: "Залишається тим самим, що був при створенні функції",
    explanation:
      "Стрілкова функція не має власного значення this. Вона 'запам'ятовує' контекст, який був під час її створення, тому this у ній не змінюється залежно від місця виклику.",
    id: "7",
    credit: 3,
  },
  {
    question: "Як можна створити глибоку копію об'єкта?",
    options: [
      "Object.assign({}, obj)",
      "JSON.parse(JSON.stringify(obj))",
      "obj.slice()",
      "obj.map()",
    ],
    answer: "JSON.parse(JSON.stringify(obj))",
    explanation:
      "JSON.parse(JSON.stringify(obj)) дозволяє створити глибоку копію об'єктів із простими структурам, але має обмеження щодо деяких типів даних (як функції, об'єкт Date, інші спеціальні об'єкти).",
    id: "8",
    credit: 4,
  },
  {
    question: "Що таке конструктор класу?",
    options: [
      "Метод, що завжди повертає null",
      "Метод, що ініціалізує об’єкт класу",
      "Окремий клас для методів",
      "Немає правильної відповіді",
    ],
    answer: "Метод, що ініціалізує об’єкт класу",
    explanation:
      "Конструктор використовується для ініціалізації об’єкта при створенні екземпляра класу.",
    id: "9",
    credit: 2,
  },
  {
    question: "Як отримати доступ до елемента DOM?",
    options: [
      "document.querySelector()",
      "document.createElement()",
      "element.addEventListener()",
      "document.body",
    ],
    answer: "document.querySelector()",
    explanation:
      "Метод querySelector дозволяє знаходити елементи за CSS-селектором.",
    id: "10",
    credit: 1,
  },
  {
    question:
      "Чим відрізняється делегування подій від традиційної обробки подій?",
    options: [
      "Дозволяє видаляти події автоматично",
      "Дозволяє оптимізувати динамічно змінювані елементи",
      "Дозволяє зберігати обробники",
      "Обробляє події для всіх дочірніх елементів через один обробник",
    ],
    answer: "Обробляє події для всіх дочірніх елементів через один обробник",
    explanation:
      "Делегування подій зменшує кількість обробників, обробляючи події спільним батьківським елементом.",
    id: "11",
    credit: 2,
  },
  {
    question:
      "Що відбувається, якщо передати відсутнє значення при деструктуризації об'єкта?",
    options: [
      "Викидає помилку",
      "Присвоює значення null",
      "Присвоює значення undefined",
      "Ігнорує значення",
    ],
    answer: "Присвоює значення undefined",
    explanation: "Відсутні властивості автоматично отримують undefined.",
    id: "12",
    credit: 1,
  },
  {
    question: "Що таке модульність коду?",
    options: [
      "Розбиття коду на частини для зменшення ваги",
      "Одна велика функція для всієї логіки",
      "Розбиття коду на незалежні частини для кращого управління",
      "Мінімізація коду",
    ],
    answer: "Розбиття коду на незалежні частини для кращого управління",
    explanation: "Модульність дозволяє структурувати код, спрощуючи підтримку.",
    id: "13",
    credit: 2,
  },
  {
    question: "Що робить localStorage?",
    options: [
      "Зберігає дані на сервері",
      "Очищає дані",
      "Зберігає дані в браузері без терміну дії",
      "Зберігає дані в браузері з терміном дії",
    ],
    answer: "Зберігає дані в браузері без терміну дії",
    explanation:
      "localStorage зберігає дані в браузері без терміну дії, навіть після закриття вкладки чи виключення комп'ютера.",
    id: "14",
    credit: 2,
  },
  {
    question: "Що повертає метод reduce()?",
    options: [
      "Новий масив",
      "Одне значення, що є результатом обчислень над усіма елементами масиву",
      "Видалений елемент",
      "Перший елемент масиву",
    ],
    answer:
      "Одне значення, що є результатом обчислень над усіма елементами масиву",
    explanation:
      "reduce() обчислює єдине значення на основі всієї колекції елементів.",
    id: "15",
    credit: 2,
  },
  {
    question: "Яка основна мета використання бібліотек у JavaScript?",
    options: [
      "Для скорочення обсягу коду і спрощення його підтримки",
      "Для автоматичного створення змінних та функцій",
      "Для забезпечення безпеки коду від шкідливих дій",
      "Для збільшення швидкості виконання JavaScript коду у браузері",
    ],
    answer: "Для скорочення обсягу коду і спрощення його підтримки",
    explanation:
      "Основна мета використання бібліотек у JavaScript — це полегшити роботу розробника, забезпечуючи готові рішення для виконання часто потрібних завдань. Вони скорочують обсяг коду та роблять його більш читабельним і підтримуваним.",
    id: "16",
    credit: 2,
  },
  {
    question:
      "Що станеться, якщо викликати setInterval всередині функції setTimeout?",
    options: [
      "Інтервал не запуститься, поки не закінчиться setTimeout",
      "Інтервал буде працювати лише один раз",
      "Інтервал почне повторюватися після завершення setTimeout, і викликатиметься з інтервалом, який заданий",
      "Таймери JavaScript не дозволяють вкладені виклики setInterval і setTimeout",
    ],
    answer:
      "Інтервал почне повторюватися після завершення setTimeout, і викликатиметься з інтервалом, який заданий",
    explanation:
      "Якщо викликати setInterval всередині setTimeout, то інтервал запуститься лише після завершення затримки setTimeout. Потім він буде повторюватися з інтервалом, який був заданий, незалежно від setTimeout.",
    id: "17",
    credit: 4,
  },
  {
    question: "Що виконує метод then() у промісах?",
    options: [
      "Відміняє проміс",
      "Запускає проміс ще раз",
      "Запускає код після виконання промісу",
      "Видаляє проміс",
    ],
    answer: "Запускає код після виконання промісу",
    explanation:
      "Метод .then() приймає функцію, яка буде виконана після завершення промісу. Якщо проміс виконується успішно, .then() обробляє його результат.",
    id: "18",
    credit: 1,
  },
  {
    question: "Що виконує асинхронна функція async?",
    options: [
      "Завжди повертає null",
      "Блокує інші функції",
      "Завжди повертає undefined",
      "Завжди повертає проміс",
    ],
    answer: "Завжди повертає проміс",
    explanation:
      "Асинхронна функція завжди повертає проміс, навіть якщо немає await.",
    id: "19",
    credit: 1,
  },
  {
    question: "Як працюють try...catch блоки в JavaScript?",
    options: [
      "Перехоплюють лише синтаксичні помилки",
      "Не працюють з асинхронними помилками",
      "Викидають помилку автоматично",
      "Перехоплюють помилки, дозволяючи їх обробку",
    ],
    answer: "Перехоплюють помилки, дозволяючи їх обробку",
    explanation:
      "try...catch обробляє помилки і дозволяє уникати зупинки виконання коду.",
    id: "20",
    credit: 2,
  },
  {
    id: "21",
    question: "Що таке hoisting у JavaScript?",
    options: [
      "Підняття функцій та змінних на верхівку області видимості",
      "Автоматичне створення класів",
      "Затримка виконання коду",
      "Створення замикань",
    ],
    answer: "Підняття функцій та змінних на верхівку області видимості",
    explanation:
      "Hoisting — це механізм, коли оголошення змінних і функцій логічно переміщуються вгору.",
    credit: 2,
  },
];
